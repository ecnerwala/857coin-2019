<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>6857Coin</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">6857Coin</h1>
</header>
<style> body{width: 640px; padding: 40px;} code{white-space: pre;} </style>
<h2 id="api">API</h2>
<p>Explore the blockchain:</p>
<blockquote>
<p><a href="/explore">/explore</a></p>
</blockquote>
<p>Get information about the team submissions:</p>
<blockquote>
<p><a href="/scores">/scores</a></p>
</blockquote>
<p>Get information about a block (as JSON):</p>
<blockquote>
<pre><code>/block/&lt;hash&gt;</code></pre>
<p>Example: get information about the genesis block:</p>
<p><a href="/block/d127746e056fa60278353a19ba090b04c021855e56e136c915778eff1f5afdfa">/block/d127746e056fa60278353a19ba090b04c021855e56e136c915778eff1f5afdfa</a></p>
</blockquote>
<p>Get a template for the next header to mine (as JSON):</p>
<blockquote>
<p><a href="/next">/next</a></p>
</blockquote>
<p>Add a block to the blockchain:</p>
<blockquote>
<pre><code>POST /add HTTP/1.1

{
  &quot;header&quot; : {
    &quot;parentid&quot;: &quot;&lt;hash&gt;&quot;,
    &quot;root&quot;: &quot;&lt;hash&gt;&quot;, (the merkle root, for now just the SHA256 hash of the block data string)
    &quot;difficulty&quot;: &lt;uint64&gt;,
    &quot;timestamp&quot;: &lt;uint64&gt;,
    &quot;nonces&quot;: [&lt;uint64&gt;,&lt;uint64&gt;],
    &quot;proofs&quot;: [&lt;BigInteger&gt;,&lt;BigInteger&gt;],
    &quot;version&quot;: &lt;byte&gt;,
  },
  &quot;block&quot; : &quot;&lt;string&gt;&quot; (the block contents, i.e. your team members separated by commas)
}</code></pre>
<p>To add a block, send a POST request to <code>/add</code> with the JSON block data in the request body. The block must satisfy the proof-of-work scheme described below. The server replies with the same information as <code>/block/&lt;new-hash&gt;</code>.</p>
</blockquote>
<h2 id="proof-of-work">Proof of Work</h2>
<p>Out proof-of-work requires two nonces, as well as two “proof” integers.</p>
<h3 id="the-group-gpm">The group <span class="math inline"><em>G</em><sup>±</sup></span></h3>
<p>Our proof-of-work works primarily in the group <span class="math inline"><em>G</em></span> of multiplication modulo the large semiprime</p>
<blockquote>
<pre><code>N = 3242094006676137707382220300856848734052071602959069588278527694894664709854063485225194595558150551
83334008931656597681774652518057328778743324904910419353236418790907181809833354759999540435699898241593
97343386039323761999256232745942994005221413223409039438367895101615370225200842862162707097865077364897</code></pre>
</blockquote>
<p>This semiprime has two unknown prime factors, and was generated by a trusted third party. It is 1022 bits long.</p>
<p>We actually will not be working directly in this group; instead, we will work in the closely related group <span class="math inline"><em>G</em><sup>±</sup></span> of pairs of integers <span class="math inline">{<em>x</em>,  − <em>x</em>}</span> modulo <span class="math inline"><em>N</em></span>. This still forms a multiplicative group, where <span class="math inline">{<em>x</em>,  − <em>x</em>} * {<em>y</em>,  − <em>y</em>} = {<em>x</em><em>y</em> mod <em>N</em>,  − <em>x</em><em>y</em> mod <em>N</em>}</span>.</p>
<p>In other words, we’re grouping together <span class="math inline">{1, <em>N</em> − 1}</span>, <span class="math inline">{2, <em>N</em> − 2}</span>, etc. as the “same” element. Using this view, we can refer to an element <span class="math inline">{<em>x</em>, <em>N</em> − <em>x</em>}</span> of <span class="math inline"><em>G</em><sup>±</sup></span> using the <em>smaller</em> residue <span class="math inline"><em>x</em></span>, so that <span class="math inline">1 ≤ <em>x</em> ≤ <em>N</em>/2</span>. In this representation, multiplication is <span class="math inline"><em>x</em> * <em>y</em> = min (<em>x</em> * <em>y</em> mod <em>N</em>, <em>N</em> − (<em>x</em> * <em>y</em> mod <em>N</em>))</span>. We will use this representation for the proof-of-work.</p>
<h3 id="the-verifiable-delay-function">The verifiable delay function</h3>
<p>A “Verifiable Delay Function” is a function which requires many sequential operations to compute, but is still possible to verify. Our proof of work is built around the VDF by Wesolowski described in <a href="https://eprint.iacr.org/2018/623">this paper</a> or <a href="https://crypto.stanford.edu/~dabo/pubs/abstracts/VDFsurvey.html">this survey</a>, though you won’t need to understand the mathematical details for this pset.</p>
<p>The Wesolowski VDF is based on iterated squaring in <span class="math inline"><em>G</em><sup>±</sup></span>. More formally, let <span class="math inline"><em>f</em>(<em>x</em>) = <em>x</em><sup>2</sup></span> for an element <span class="math inline"><em>x</em> ∈ <em>G</em><sup>±</sup></span>. Then, <span class="math inline"><em>V</em><em>D</em><em>F</em>(<em>g</em>, <em>T</em>)</span> will be <span class="math inline"><em>f</em>(<em>f</em>(…<em>f</em>(<em>g</em>)…))</span>, where we call <span class="math inline"><em>f</em></span> <span class="math inline"><em>T</em></span> times. Equivalently, this equals <span class="math inline"><em>g</em><sup>2<sup><em>T</em></sup></sup></span>. This is difficult to compute in fewer than <span class="math inline"><em>T</em></span> group operations (the order of <span class="math inline"><em>g</em></span> is unknown, as <span class="math inline"><em>N</em></span> is a semiprime).</p>
<p>Unfortunately, this means is no way to directly verify that someone computed <span class="math inline"><em>g</em><sup>2<sup><em>T</em></sup></sup></span> without recomputing it yourself. We remedy this by attaching a “proof” to the VDF.</p>
<p>Let <span class="math inline"><em>h</em></span> be the claimed value of <span class="math inline"><em>g</em><sup>2<sup><em>T</em></sup></sup></span>. Then, we will pseudorandomly generate a challenge prime <span class="math inline"><em>l</em> = <em>H</em><em>a</em><em>s</em><em>h</em>(<em>T</em>, <em>g</em>, <em>h</em>)</span> using some hash function (described later). Let <span class="math inline"><em>q</em> = ⌊2<sup><em>T</em></sup>/<em>l</em>⌋</span> and <span class="math inline"><em>r</em> = 2<sup><em>T</em></sup> mod <em>l</em></span>. Then, the miner must also compute and attach <span class="math inline"><em>π</em> = <em>g</em><sup><em>q</em></sup></span> as a proof, so that a verifier can validate that <span class="math inline"><em>h</em> = <em>π</em><sup><em>l</em></sup><em>g</em><sup><em>r</em></sup></span>. (The unforgeability of this proof relies on some Diffie-Hellman-like assumptions, which you can find in the linked papers.)</p>
<p>Thus, the overall VDF is <span class="math inline"><em>V</em><em>D</em><em>F</em>(<em>g</em>, <em>T</em>) = (<em>h</em>, <em>π</em>)</span>, for <span class="math inline"><em>h</em> = <em>g</em><sup>2<sup><em>T</em></sup></sup></span> and <span class="math inline"><em>π</em> = <em>g</em><sup><em>q</em></sup></span> as described above.</p>
<p>The proof-of-work will require finding a <span class="math inline"><em>T</em></span> such that <span class="math inline"><em>h</em> = <em>g</em><sup>2<sup><em>T</em></sup></sup></span> is small. We will elaborate further later.</p>
<h3 id="protocol-details">Protocol details</h3>
<p>We now formalize the details of the protocol.</p>
<p>For a block header B to be added into the blockchain, it must be accepted by the following algorithm.</p>
<p>First, we compute a seed <span class="math inline"><em>g</em> ∈ <em>G</em><sup>±</sup></span>, using the first nonce, <code>B.nonces[0]</code>. We will build it in 4 blocks; each block is going to be the SHA-256 hash of the concatenation of the following data:</p>
<ul>
<li>the bytes of parentid interpreted as a 32-byte number</li>
<li>the bytes of root interpreted as a 32-byte number</li>
<li>the 8 bytes of difficulty in big-endian order</li>
<li>the 8 bytes of timestamp in big-endian order</li>
<li>the 8 bytes of the first nonce in big-endian order</li>
<li>the single version byte</li>
<li>the block index, as a 0-indexed byte</li>
</ul>
<p>The seed will be the concatenation of the 4 blocks, interpreted as a 1024-bit big-endian integer and reduced to an element of <span class="math inline"><em>G</em></span>.</p>
<p>In other words:</p>
<blockquote>
<pre><code>seed_block[i] = SHA256(HexDecode(B.parentid)
                     + HexDecode(B.root)
                     + Bytes(B.difficulty)
                     + Bytes(B.timestamp)
                     + Bytes(B.nonces[0])
                     + B.version
                     + i)
seed_integer = FromBytes(seed_block[0] + seed_block[1] + seed_block[2] + seed_block[3])
seed = min(seed_integer % N, N - seed_integer % N)</code></pre>
</blockquote>
<p>Now, let <code>T = B.nonces[1]</code>, let <code>h = B.proofs[0]</code>, and let <span class="math inline"><em>π</em></span> <code>= B.proofs[1]</code>.</p>
<p>Then, the proof-of-work at difficulty <span class="math inline"><em>d</em></span> must satisfy:</p>
<ul>
<li><span class="math inline">1 ≤ <em>h</em> ≤ <em>N</em>/2</span> and <span class="math inline">1 ≤ <em>π</em> ≤ <em>N</em>/2</span> (they are elements of <span class="math inline"><em>G</em><sup>±</sup></span>)</li>
<li><span class="math inline"><em>h</em> = <em>g</em><sup>2<sup><em>T</em></sup></sup></span>; the verifier will check this using the proof <span class="math inline"><em>π</em></span>, i.e. check that <span class="math inline"><em>h</em> = <em>g</em><sup><em>r</em></sup><em>π</em><sup><em>l</em></sup></span> for challenge <span class="math inline"><em>l</em> = <em>H</em><em>a</em><em>s</em><em>h</em>(<em>T</em>, <em>g</em>, <em>h</em>)</span> and <span class="math inline"><em>r</em> = 2<sup><em>T</em></sup> mod <em>l</em></span> (see below).</li>
<li><span class="math inline"><em>T</em> &gt; <em>d</em></span> and <span class="math inline"><em>h</em> ≤ |<em>G</em><sup>±</sup>|/<em>d</em> = <em>N</em>/(2<em>d</em>)</span>; together, these force each miner to square at least <span class="math inline"><em>d</em></span> times, and then <span class="math inline"><em>d</em></span> more in expectation to find a valid <span class="math inline"><em>h</em></span>.</li>
</ul>
<p>The challenge <span class="math inline"><em>l</em></span> is generated as follows: repeatedly generate potential challenges until we find a prime value. In the <span class="math inline"><em>i</em></span>th round (0-indexed), concatenate the following data:</p>
<ul>
<li>the 8 bytes of T in big-endian order</li>
<li>the 128 bytes of g in big-endian order</li>
<li>the 128 bytes of h in big-endian order</li>
<li>the round number i as a single byte</li>
</ul>
<p>In other words:</p>
<blockquote>
<pre><code> l_candidate[i] = SHA256(Bytes(T) + Bytes(g) + Bytes(h) + i)</code></pre>
</blockquote>
<p>We take <span class="math inline"><em>l</em></span> to be the first <code>l_candidate[i]</code> which is prime. Then, the miner or verifier can compute <span class="math inline"><em>q</em> = ⌊2<sup><em>T</em></sup>/<em>l</em>⌋</span> and <span class="math inline"><em>r</em> = 2<sup><em>T</em></sup> mod <em>l</em></span>. A miner should compute <span class="math inline"><em>π</em> = <em>g</em><sup><em>q</em></sup></span> to satisfy the proof, and a verifier checks that <span class="math inline"><em>h</em> = <em>π</em><sup><em>l</em></sup><em>g</em><sup><em>r</em></sup></span>.</p>
<p>For a block B to be accepted into the blockchain, the following must additionally be true:</p>
<ul>
<li><code>B.parentid</code> is the SHA256 Hash of a header in the blockchain.</li>
<li><code>B.root</code> is the SHA256 hash of the block contents.</li>
<li><code>B.difficulty &gt;= MinimumDifficulty = 200,000</code> and matches the target difficulty.</li>
<li><code>B.timestamp</code> must be less than 5 minutes off from server.</li>
</ul>
<p>The target block interval is 1 minute. Difficulty will be retargeted every 60 blocks: make sure you start early!</p>
<h2 id="rules">Rules</h2>
<ul>
<li>Do not seek outside help to mine blocks.</li>
<li>You may use GPUs, FPGAs, ASICs, etc.</li>
<li>Do not abuse MIT resources to mine blocks.</li>
<li>Limit the number of requests you send to the server to 4 requests per minute.</li>
</ul>
</body>
</html>
