% 6857Coin

[//]: <> (Build with `pandoc index.md -o index.html`)

<style> body{width: 640px; padding: 40px;} code{white-space: pre;} </style>

## API

Explore the blockchain:

> [/explore](/explore)

Get information about the team submissions:

> [/scores](/scores)

Get information about a block (as JSON):

>     /block/<hash>
>
> Example: get information about the genesis block:
>
> [/block/18be4005f813360c14a360ab2ca468772e9ff39e684fea89294aeb9df0c7d85e](/block/18be4005f813360c14a360ab2ca468772e9ff39e684fea89294aeb9df0c7d85e)

Get a template for the next header to mine (as JSON):

> [/next](/next)

Add a block to the blockchain:

>     POST /add HTTP/1.1
>
>     {
>       "header" : {
>         "parentid": "<hash>",
>         "root": "<hash>", (the merkle root, for now just the SHA256 hash of the block data string)
>         "difficulty": <uint64>,
>         "timestamp": <uint64>,
>         "nonces": [<uint64>,<uint64>],
>         "proofs": [<BigInteger>,<BigInteger>],
>         "version": <byte>,
>       },
>       "block" : "<string>" (the block contents, i.e. your team members separated by commas)
>     }
>
> To add a block, send a POST request to `/add` with the JSON block data in the request body. The block must satisfy the proof-of-work scheme described below.
> The server replies with the same information as `/block/<new-hash>`.

## Proof of Work

Out proof-of-work requires two nonces, as well as two "proof" integers.

### The group $G^\pm$

Our proof-of-work works primarily in the group $G$ of multiplication modulo the large
semiprime

>     N = 3242094006676137707382220300856848734052071602959069588278527694894664709854063485225194595558150551
>     83334008931656597681774652518057328778743324904910419353236418790907181809833354759999540435699898241593
>     97343386039323761999256232745942994005221413223409039438367895101615370225200842862162707097865077364897

This semiprime has two unknown prime factors, and was generated by a trusted
third party. It is 1022 bits long.

We actually will not be working directly in this group; instead, we will work in
the closely related group $G^\pm$ of pairs of integers $\{x, -x\}$ modulo $N$.
This still forms a multiplicative group, where $\{x, -x\} * \{y, -y\} = \{xy \
\mod N, -xy \ \mod N\}$.

In other words, we're grouping together $\{1, N-1\}$, $\{2, N-2\}$, etc.\ as the
"same" element. Using this view, we can refer to an element $\{x, N-x\}$ of $G^\pm$ using the
*smaller* residue $x$, so that $1 \le x \le N/2$. In this representation,
multiplication is $x * y = \min(x * y \ \mod N, N - (x * y \ \mod N))$. We will
use this representation for the proof-of-work.

### The verifiable delay function

A "Verifiable Delay Function" is a function which requires many sequential
operations to compute, but is still possible to verify. Our proof of work is
built around the VDF by Wesolowski described in [this
paper](https://eprint.iacr.org/2018/623) or [this
survey](https://crypto.stanford.edu/~dabo/pubs/abstracts/VDFsurvey.html), though
you won't need to understand the mathematical details for this pset.

The Wesolowski VDF is based on iterated squaring in $G^{\pm}$. More formally,
let $f(x) = x^2$ for an element $x \in G^\pm$. Then, $VDF(g, T)$ will be
$f(f(\ldots f(g) \ldots))$, where we call $f$ $T$ times. Equivalently, this
equals $g^{2^{T}}$. This is difficult to compute in fewer than $T$ group
operations (the order of $g$ is unknown, as $N$ is a semiprime).

Unfortunately, this means is no way to directly verify that someone
computed $g^{2^T}$ without recomputing it yourself. We remedy this by attaching
a "proof" to the VDF.

Let $h$ be the claimed value of $g^{2^T}$. Then, we will
pseudorandomly generate a challenge prime $l = Hash(T, g, h)$ using some hash
function (described later). Let $q = \lfloor 2^T/l \rfloor$ and $r = 2^T \
\mod l$. Then, the miner must also compute and attach $\pi = g^q$ as a proof, so
that a verifier can validate that $h = \pi^l g^r$. (The unforgeability of this
proof relies on some Diffie-Hellman-like assumptions, which you can find in the
linked papers.)

Thus, the overall VDF is $VDF(g, T) = (h, \pi)$, for $h = g^{2^{T}}$ and $\pi =
g^q$ as described above.

The proof-of-work will require finding a $T$ such that $h = g^{2^{T}}$ is small. We will
elaborate further later.

### Protocol details

We now formalize the details of the protocol.

For a block header B to be added into the blockchain, it must be accepted by the following algorithm.

First, we compute a seed $g \in G^\pm$, using the first nonce, `B.nonces[0]`. We
will build it in 4 blocks; each block is going to be the SHA-256 hash of the
concatenation of the following data:

* the bytes of parentid interpreted as a 32-byte number
* the bytes of root interpreted as a 32-byte number
* the 8 bytes of difficulty in big-endian order
* the 8 bytes of timestamp in big-endian order
* the 8 bytes of the first nonce in big-endian order
* the single version byte
* the block index, as a 0-indexed byte

The seed will be the concatenation of the 4 blocks, interpreted as a 1024-bit
big-endian integer and reduced to an element of $G$.

In other words:

>     seed_block[i] = SHA256(HexDecode(B.parentid)
>                          + HexDecode(B.root)
>                          + Bytes(B.difficulty)
>                          + Bytes(B.timestamp)
>                          + Bytes(B.nonces[0])
>                          + B.version
>                          + i)
>     seed_integer = FromBytes(seed_block[0] + seed_block[1] + seed_block[2] + seed_block[3])
>     seed = min(seed_integer % N, N - seed_integer % N)

Now, let `T = B.nonces[1]`, let `h = B.proofs[0]`, and let $\pi$ ` = B.proofs[1]`.

Then, the proof-of-work at difficulty $d$ must satisfy:

* $1 \le h \le N/2$ and $1 \le \pi \le N/2$ (they are elements of $G^\pm$)
* $h = g^{2^T}$; the verifier will check this using the proof $\pi$, i.e.\ check
  that $h = g^r \pi^l$ for challenge $l = Hash(T, g, h)$ and $r = 2^T \ \mod l$
  (see below).
* $T > d$ and $h \le |G^\pm|/d = N/(2d)$; together, these force each miner to
  square at least $d$ times, and then $d$ more in expectation to find a valid
  $h$.

The challenge $l$ is generated as follows: repeatedly generate potential
challenges until we find a prime value. In the $i$th round (0-indexed),
concatenate the following data:

* the 8 bytes of T in big-endian order
* the 128 bytes of g in big-endian order
* the 128 bytes of h in big-endian order
* the round number i as a single byte

In other words:

>      l_candidate[i] = SHA256(Bytes(T) + Bytes(g) + Bytes(h) + i)

We take $l$ to be the first `l_candidate[i]` which is prime. Then, the miner or
verifier can compute $q = \lfloor 2^T / l \rfloor$ and $r = 2^T \ \mod l$. A
miner should compute $\pi = g^q$ to satisfy the proof, and a verifier checks
that $h = \pi^l g^r$.

For a block B to be accepted into the blockchain, the following must
additionally be true:

* `B.parentid` is the SHA256 Hash of a header in the blockchain.
* `B.root` is the SHA256 hash of the block contents.
* `B.difficulty >= MinimumDifficulty = 200,000` and matches the target difficulty.
* `B.timestamp` must be less than 5 minutes off from server.

The target block interval is 1 minute. Difficulty will be retargeted every 60 blocks: make sure you start early!

## Rules
* Do not seek outside help to mine blocks.
* You may use GPUs, FPGAs, ASICs, etc.
* Do not abuse MIT resources to mine blocks.
* Limit the number of requests you send to the server to 4 requests per minute.
